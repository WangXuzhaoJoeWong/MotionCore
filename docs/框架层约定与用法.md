# 框架层约定与用法（wxz::framework）

本文档是 MotionCore 框架层（`wxz::framework`）对业务侧的**权威入口**，目标是让业务代码写法尽量接近 ROS2/rclcpp：

- pub/sub/service/client API 统一
- 线程模型统一（业务回调不跑 DDS listener 线程）
- QoS / Topic 约定统一
- recv/drop/reject 指标口径统一

> 对应代码位置：`MotionCore/include/framework/`。

---

## 1. 线程模型约定（最重要）

约定：FastDDS listener 线程只负责“收包 + 拷贝/lease”，不执行任何业务回调。

- 所有业务回调必须被投递到 `Strand` 或 `Executor`。
- 推荐：单线程主循环 + `Executor(threads=0)` + `spin_once()` 驱动；并用 `Strand` 保证串行化。

典型主循环模板（推荐用 framework 的 `spin(node)` 或 `spin_once` 统一驱动）：

```cpp
wxz::framework::Node node({
  .base = cfg,
  .logger = &logger,
  .metrics_scope = cfg.service,
});

node.install_signal_handlers();

// 最简入口：更像 rclcpp::spin(node)
wxz::framework::spin(node);

// 如需更细粒度控制（自定义循环频率/时间片）：
// wxz::framework::Rate rate(std::chrono::milliseconds(10));
// while (node.running()) {
//   (void)wxz::framework::spin_once(node, std::chrono::milliseconds(10));
//   rate.sleep();
// }
```

高级用法（与 ROS2 类似：外部注入 executor/strand，便于多 strand 分域串行化）：

```cpp
wxz::core::Executor ex({.threads=0});
ex.start();
wxz::core::Strand ingress(ex);

wxz::framework::Node node({
  .base = cfg,
  .executor = &ex,
  .default_strand = &ingress,
  .logger = &logger,
  .metrics_scope = cfg.service,
});

node.install_signal_handlers();
while (node.running()) {
  (void)wxz::framework::spin_once(node, std::chrono::milliseconds(10));
}
```

---

## 2. CallbackGroup（更像 ROS2 的回调分派域）

`wxz::framework::CallbackGroup` 用于显式控制回调在哪个“分派域”执行：

- `MutuallyExclusive`：串行回调（内部是 `Strand`）
- `Reentrant`：允许并发回调（内部是 `Executor`）

示例：

```cpp
auto sub = node.create_subscription_eventdto_shared(
  "/arm/status",
  [&](const ::EventDTO& dto){ /* 串行回调 */ },
  node.create_callback_group(wxz::framework::CallbackGroupType::MutuallyExclusive));

auto sub2 = node.create_subscription_eventdto_shared(
  "/arm/throughput",
  [&](const ::EventDTO& dto){ /* 可能并发 */ },
  node.create_callback_group(wxz::framework::CallbackGroupType::Reentrant));
```

补充约定：

- Node 内置默认 callback group（`MutuallyExclusive`，复用 `default_strand`）。不显式指定 group 的 `create_*` 会走默认组。
- 所有接收 `CallbackGroup&` 的 API 也提供 `CallbackGroupPtr` 重载：可以直接传 `node.create_callback_group(...)` 的返回值，不需要写 `*group`。
- 传 `nullptr` 作为 group 等价于使用默认 callback group。

选择建议：

- 优先用 `MutuallyExclusive`：有序、好推理，适合“更新内部状态机/共享状态”的回调。
- 只有当回调是线程安全且不依赖顺序时才用 `Reentrant`：例如 CPU 密集的纯计算、无共享状态或内部已做好加锁。
- `Reentrant` 下同一订阅/同一 service 的回调可能并发执行，必须自行处理共享数据竞争与时序问题。

---

## 3. Topic 命名约定

### 3.1 RPC 统一命名

RPC 统一使用：

- 请求：`/svc/<service>/rpc/request`
- 响应：`/svc/<service>/rpc/reply`

框架层提供 helper：

- `wxz::framework::default_rpc_request_topic(service)`
- `wxz::framework::default_rpc_reply_topic(service)`

> 注意：RPC 的 client/server 必须使用同一对 topic。

### 3.2 事件/状态类 topic

事件类（EventDTO CDR）推荐使用 `Node::create_subscription_eventdto` / `Node::create_publisher_eventdto`。

可选：使用 `*_shared()` 返回 `std::shared_ptr` 句柄（更像 rclcpp 的 SharedPtr 体验）。

- 订阅侧自动：leased buffer + decode + schema 校验 + drop 统计
- 发布侧自动：encode + drop 统计

---

## 4. QoS 约定

- 默认 QoS：可靠（reliable） + keep_last(16) + deadline(1s) + async_publish=true
  - 来自 `wxz::core::default_reliable_qos()`

框架层提供更像 ROS2 的封装：

```cpp
auto qos = wxz::framework::QoS::reliable().keep_last(32).deadline(std::chrono::seconds(1));
// 需要时：传给 create_publisher/create_subscription 的 extra.qos
```

---

## 5. Service / Client 用法

### 5.1 Service（RpcServer）

```cpp
// 固定模板：创建 group → create_service/create_subscription/create_client 都带 group
auto group = node.create_callback_group(wxz::framework::CallbackGroupType::MutuallyExclusive);

auto sub = node.create_subscription_eventdto_shared(
  "/arm/status",
  [&](const ::EventDTO& dto) {
    // ...
  },
  group);

auto svc = node.create_service(
  wxz::framework::RpcService::Options::builder("arm_control")
    .sw_version("1.2.3")
    .metrics_scope("arm_control")
    // 可选：自定义 topic/qos
    // .request_topic("/svc/arm_control/rpc/request")
    // .reply_topic("/svc/arm_control/rpc/reply")
    // .qos(wxz::core::default_reliable_qos())
    .build(),
  group);

svc->add_ping_handler();
svc->add_handler("do_something", [&](const wxz::framework::RpcService::Json& params) {
  wxz::framework::RpcService::Reply rep;
  rep.status = wxz::framework::Status::ok_status();
  rep.result = {{"echo", params}};
  return rep;
});
svc->start(&logger);
```

默认不带 group：走 Node 默认 callback group（MutuallyExclusive + default_strand）：

```cpp
auto svc = node.create_service("arm_control", /*sw_version=*/"1.2.3");
```

### 5.2 Client（RpcClient）

```cpp
auto group = node.create_callback_group(wxz::framework::CallbackGroupType::MutuallyExclusive);

auto cli = node.create_client(
  wxz::framework::RpcServiceClient::Options::builder("arm_control")
    .client_id_prefix("bt")
    .timeout(std::chrono::milliseconds(500))
    .metrics_scope("arm_control")
    .build(),
  group);
cli->start();

auto rep = cli->call("do_something", { {"x", 1} }, std::chrono::milliseconds(500));
if (!rep.status.ok) {
  // rep.status.err_code: RpcErrorCode 的 int 值
  // rep.status.err: reason 或 code 字符串
}
```

默认不带 group：走 Node 默认 callback group（MutuallyExclusive + default_strand）：

```cpp
auto cli = node.create_client("arm_control", /*client_id_prefix=*/"bt");
```

### 5.3 Typed wrapper（推荐，提升可读性）

不改变底层 DTO/RPC，只是把常用 op 的请求/响应“类型化”，让读代码时一眼知道字段结构。

```cpp
#include "workstation/arm_control_rpc.h"

auto cli = node.create_client(
  wxz::framework::RpcServiceClient::Options::builder("arm_control")
    .client_id_prefix("bt")
    .timeout(std::chrono::milliseconds(500))
    .build());
cli->start();

auto rep = wxz::workstation::arm_control::rpc::ping(*cli, std::chrono::milliseconds(200));
// rep.status.ok / rep.value.service / rep.value.sw_version / rep.value.ts_ms ...
```

---

## 6. Parameter 用法

Node 提供更像 ROS2 的便捷接口：

```cpp
node.declare_parameter("planner.timeout_ms", 2000);
const int timeout_ms = node.get_parameter_or<int>("planner.timeout_ms", 2000);
```

声明/读取/设置：

```cpp
node.parameters().declare("planner.timeout_ms", 2000);

auto v = node.parameters().get("planner.timeout_ms");

auto st = node.parameters().set("planner.timeout_ms", 2500);
```

订阅参数变化（回调投递到默认 strand）：

```cpp
node.parameters().on_changed("planner.timeout_ms", node.default_strand(),
  [&](const std::string& key, const wxz::framework::Parameters::Value& value) {
    // handle change
  });
```

---

## 7. Timer/Rate 用法

由于当前 `wxz::core::Executor` 没有“延迟任务”，framework timer 采用显式 tick 模式：

- 创建：`node.create_wall_timer(period, cb)`
- 驱动：主循环调用 `node.tick_timers()`

```cpp
auto t = node.create_wall_timer_scoped(std::chrono::seconds(1), [&] {
  // periodic work (runs on default_strand)
});
```

订阅最短写法（schema 可选）：

```cpp
auto sub = node.create_subscription_eventdto_shared(
  "/arm/status",
  [&](const ::EventDTO& dto) {
    // ...
  });
```

链式 Options（便于逐项配置/复用）：

```cpp
auto sub = node.create_subscription_eventdto_shared(
  "/arm/status",
  [&](const ::EventDTO& dto) {
    // ...
  },
  wxz::framework::EventDtoSubscription::Options::builder()
    .schema_id("ws.arm_status.v1")
    .qos(wxz::core::default_reliable_qos())
    .max_payload(16 * 1024)
    .pool_buffers(128));
```

发布侧也支持 Options builder：

```cpp
auto pub = node.create_publisher_eventdto_shared(
  wxz::framework::EventDtoPublisher::Options::builder("/arm/status")
    .qos(wxz::core::default_reliable_qos())
    .max_payload(16 * 1024));
```

说明：`create_wall_timer_scoped` 返回 RAII timer，析构会自动 cancel。

---

## 8. 指标口径（recv/drop/reject）

- `Executor` 投递拒绝：`wxz.executor.post.reject`
- `Strand` 投递拒绝：`wxz.strand.post.reject`
- 订阅接收：`wxz.workstation.subscription.recv`
- 订阅 drop：`wxz.workstation.subscription.drop`（reason: decode_failed/schema_mismatch/user_exception/...）
- 发布 ok/drop：`wxz.workstation.publisher.ok` / `wxz.workstation.publisher.drop`

> 备注：目前 metrics 名称沿用 workstation 前缀，后续如需统一命名空间，可在框架层做一次集中重命名。
