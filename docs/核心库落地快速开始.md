# 核心库落地快速开始（安装态优先：install-tree first）

> 状态（2026-01）：本文主要面向 MotionCore “核心层（wxz::core）”的安装/最小用法示例。
>
> 业务侧/服务侧请优先使用 `wxz::framework`（更接近 rclcpp 的薄封装），并以 MotionCore/docs/框架层约定与用法.md 为准。

目标：把“安装产物 = 唯一运行形态”落实成可复制的命令。

说明：推荐使用 build 目录生成的 `install.sh` 安装（它会显式指定 `--prefix`，避免不同机器/历史 cache 导致安装前缀不一致）。

## 1. 最小构建（MotionCore 独立工程）

```bash
cd MotionCore
mkdir -p build
cd build

cmake .. \
  -DCMAKE_BUILD_TYPE=Release \
  -DWXZ_INSTALL_DOCS=OFF

make -j"$(nproc)"
```

## 2. 安装态优先（install-tree first）：生成安装态产物

安装态验证的关键点是：仅依赖安装前缀下的产物与配置样例，避免不小心依赖 build-tree。

## 3. 下游工程使用（find_package）

安装（推荐用 `install.sh`，默认前缀为 build 目录）：

```bash
cd MotionCore/build
./install.sh

# 或安装到系统前缀（需要权限）
# cd MotionCore/build
# sudo ./install.sh /opt/motioncore
```

下游 CMake：

```cmake
find_package(MotionCore CONFIG REQUIRED)
add_executable(my_app main.cpp)
target_link_libraries(my_app PRIVATE MotionCore::MotionCore)
```

如果你希望“单一前缀”同时包含 FastDDS 依赖：建议在平台侧统一约束依赖版本与前缀路径（避免 fastcdr 多版本混用）。

## 4. 常见问题（最小排障）

- 若遇到安装导出/找包问题：优先检查 `find_package(MotionCore CONFIG REQUIRED)` 是否能在安装前缀下工作。

## 5. 并发与回调（ROS2-like 推荐形态）

核心原则：FastDDS 的回调线程只做轻量工作（copy + dispatch），业务回调应显式绑定到 `Executor/Strand`，由统一 `spin()` 线程驱动。

推荐用法：

```cpp
#include "executor.h"
#include "strand.h"
#include "byte_buffer_pool.h"
#include "fastdds_channel.h"

wxz::core::Executor exec({.threads = 0});
(void)exec.start();
wxz::core::Strand ingress(exec);
std::thread spin_thread([&] { exec.spin(); });

wxz::core::ByteBufferPool pool({.buffers = 128, .buffer_capacity = 8192});
wxz::core::FastddsChannel sub(/*domain*/ 0, /*topic*/ "/demo", wxz::core::default_reliable_qos(), 8192,
                              /*enable_pub=*/false, /*enable_sub=*/true);

sub.subscribe_leased_on(pool, ingress, [&](wxz::core::ByteBufferLease&& msg) {
  // 在 ingress strand 上执行（不在 DDS 回调线程上）。
  // decode / parse / 状态更新写这里。
});

exec.stop();
spin_thread.join();
```

并发/线程模型与排障指标口径见：`docs/框架层约定与用法.md`（文末“排障速查”）。

## 6. 示例程序

说明：为保持核心库（MotionCore）干净，仓库不再在 `MotionCore/` 下内置 `examples/` 目录。

可运行示例请参考：

- 仓库根目录 `examples/`（例如 `examples/core_api_minimal.cpp` 等）

## 7. 时钟与时间同步（Clock/TimeSync）

MotionCore 提供可插拔时钟接口，便于：

- 回放/仿真（注入自定义 Clock）
- 统一时间来源（system/steady）
- 以最小成本输出 NTP/PTP 同步健康 metrics（Linux 默认基于 `adjtimex`）

关键接口：

- `clock.h`：`wxz::core::Clock / set_clock()`
- `time_sync.h`：`probe_timesync()/publish_timesync_metrics()`
- `node_base.h`：`NodeBaseConfig::timesync_period_ms`（周期探测并输出 metrics）

最小用法（NodeBase 自动上报 timesync metrics）：

```cpp
#include "node_base.h"

wxz::core::NodeBaseConfig cfg;
cfg.service = "bt_service";
cfg.type = "workstation";
cfg.domain = 0;
cfg.timesync_period_ms = 5000;      // 0=禁用；>0=每 5s 探测一次
cfg.timesync_scope = "bt_service"; // 可选：用于 metrics label

wxz::core::NodeBase node(cfg);
node.install_signal_handlers();

while (node.running()) {
  node.tick();
  node.sleep_for(std::chrono::milliseconds(50));
}
```

## 8. 最小 RPC（Service/Client + timeout + error + metrics）

基于 `FastddsChannel` 的请求/响应式 RPC：

- Server：注册 `op -> handler(params)`
- Client：`call(op, params, timeout)`，返回统一错误码 + reason
- 双端输出最小 metrics（`wxz.rpc.*`）

```cpp
#include "executor.h"
#include "rpc/rpc_client.h"
#include "rpc/rpc_service.h"

wxz::core::Executor exec({.threads = 0});
(void)exec.start();
std::thread spin([&] { exec.spin(); });

// Server（建议采用 /svc/<service>/rpc/* 约定，避免 topic 冲突）
wxz::core::rpc::RpcServer server({
  .domain = 0,
  .request_topic = "/svc/demo_rpc/rpc/request",
  .reply_topic = "/svc/demo_rpc/rpc/reply",
  .service_name = "demo_rpc",
});
server.bind_scheduler(exec);
server.add_handler("ping", [](const wxz::core::rpc::RpcServer::Json&) {
  wxz::core::rpc::RpcServer::Reply r;
  r.ok = true;
  r.result = wxz::core::rpc::RpcServer::Json::object({{"pong", 1}});
  return r;
});
(void)server.start();

// Client
wxz::core::rpc::RpcClient client({
  .domain = 0,
  .request_topic = "/svc/demo_rpc/rpc/request",
  .reply_topic = "/svc/demo_rpc/rpc/reply",
  .client_id_prefix = "bt_service",
});
client.bind_scheduler(exec);
(void)client.start();

auto res = client.call("ping", wxz::core::rpc::RpcClient::Json::object(), std::chrono::milliseconds(200));
if (!res.ok()) {
  // res.code/res.reason
}

client.stop();
server.stop();
exec.stop();
spin.join();
```

提示：服务侧更推荐直接使用框架层封装：

- `wxz::framework::RpcService` / `wxz::framework::RpcServiceClient`
- `wxz::framework::Node::create_service/create_client`



## 附：能力清单（待完善）


